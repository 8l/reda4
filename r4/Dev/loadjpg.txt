| JPG decoder
| PHREDA 2015
|-----------------------
^r4/lib/gui.txt
^r4/lib/trace.txt

#imem
#emem

#restart

#imgrows
#imgcols
#Image.NumComp
#Image.HuffACTableY
#Image.HuffDCTableY
#Image.HuffACTableCbCr
#Image.HuffDCTableCbCr
#Image.SamplesY
#Image.QuantTableY
#Image.SamplesCbCr
#Image.QuantTableCbCr

| index(16)-length(8)-code(8)
#HuffmanDC0 )( 1028
#HuffmanDC1 )( 1028
#HuffmanAC0 )( 1028
#HuffmanAC1 )( 1028

#QuantTable )( 512 | 2x8x8

#JPGzz (
 0  1  8 16  9  2  3 10 17 24 32 25 18 11  4  5
12 19 26 33 40 48 41 34 27 20 13  6  7 14 21 28
35 42 49 56 57 50 43 36 29 22 15 23 30 37 44 51
58 59 52 45 38 31 39 46 53 60 61 54 47 55 62 63 -1 )

#aanscales | precomputed values scaled up by 14 bits
   16384  22725  21407  19266  16384  12873   8867   4520
   22725  31521  29692  26722  22725  17855  12299   6270
   21407  29692  27969  25172  21407  16819  11585   5906
   19266  26722  25172  22654  19266  15137  10426   5315
   16384  22725  21407  19266  16384  12873   8867   4520
   12873  17855  16819  15137  12873  10114   6967   3552
    8867  12299  11585  10426   8867   6967   4799   2446
    4520   6270   5906   5315   4520   3552   2446   1247

:get8 | adr -- adr+ 8b
	c@+ $ff and ;
:get16 | adr -- adr+ 16b
	c@+ $ff and 8 << swap c@+ $ff and rot or ;
:readNumber | adr -- adr+ 16b
	2 + get16 ;
:readComm | adr -- adr+
	get16 2 - ( 1? )( 1- swap 1+ swap ) drop ;

#bbit
#bitl

:read1bit | adr -- adr bit
	bitl 0? ( drop c@+ 'bbit ! 8 )
	1- 'bitl !
	bbit dup 2/ 'bbit !
	1 and ;

:readnbit | adr n -- adr nro
	swap 0 >r
	bbit bitl 0 | a bb bn len
	( pick4 <? )( swap	| a bb len bn
    	0? ( drop nip swap c@+ rot 8 )
		1- pick2 1 and
		pick2 << r+
		rot 2/ swap rot 1+ ) drop
	'bitl ! 'bbit !
	nip r> ;

|--------------------------
:getcase1
	swap
	get8 dup 15 and swap 4 >> * 'Image.SamplesY !
	get8 'Image.QuantTableY !
	swap ;

:getcase2
	swap
	get8 dup 15 and swap 4 >> * 'Image.SamplesCbCr !
	get8 'Image.QuantTableCbCr !
	swap ;

:JPGGetImageAttr | adr -- adr+
	3 +	| Length of segment
	get16 'imgrows !
	get16 'imgcols !
	get8	| Number of components
	( 1? )( swap
		get8
		1- 0? ( getcase1 )( getcase2 )
		drop swap 1- ) drop ;

|----------------------------------
#curnum

:getHuffTable | a table -- a total
	>r
	emem >r
	16 ( 1? )( 1- swap
		get8 r!+ swap ) drop
	rdrop
	0 'curnum !
	emem 0 ( 16 <? )( 1+	| adr ht i
		rot rot 			| i adr ht
		@+ ( 1? )( 1- rot 	| i ht cnt adr
	        get8 8 << pick4 or curnum 16 << or r!+
			1 'curnum +!
			rot rot ) drop
		curnum 2* 'curnum !
		rot ) 2drop			| adr ht
	rdrop ;

:tableHuff | a -- a
	get8
	$00 =? ( drop 'HuffmanDC0 getHuffTable ; )
	$01 =? ( drop 'HuffmanDC1 getHuffTable ; )
	$10 =? ( drop 'HuffmanAC0 getHuffTable ; )
	$11 =? ( drop 'HuffmanAC1 getHuffTable ; )
	drop ;

:JPGGetHuffTables | a -- a
	get16 2 - over + swap
	( over <? )( tableHuff ) nip ;

|-----------------
:PGGetQuantTables | a -- a
	get16 2 - over + swap
	( over <? )(
		get8
		1 and 8 << 'QuantTable + >r
		'jpgzz ( c@+ 0 >=? )(	| a zz index
			2 << rot get8		| zz index a byte
			pick2 'aanscales + @ * 12 >> | zz index a value
			rot r + !			| zz a
			swap ) 2drop
		rdrop
		) nip ;

|-----------------
:SOSline
	get8
	1 =? ( drop get8 dup 15 and 'Image.HuffACTableY ! 4 >> 'Image.HuffDCTableY ! ; )
	drop get8 dup 15 and 'Image.HuffACTableCbCr ! 4 >> 'Image.HuffDCTableCbCr ! ;

:JPGGetSOS | a --
	2 + get8 dup 'Image.NumComp !
	( 1? )(	1- swap SOSline swap ) drop
	3 + ;

|-----------------
#YVector1 )( 256 |[8][8];              // 4 vectors for Y attribute
#YVector2 )( 256 |[8][8];              // (not all may be needed)
#YVector3 )( 256 |[8][8];
#YVector4 )( 256 |[8][8];
#CbVector )( 256 |[8][8];              // 1 vector for Cb attribute
#CrVector )( 256 |[8][8];
#yindex

| index(16)-length(8)-code(8)
|------------------------------
:searchcode | code len list -- code len -1/code
	>r
	over 16 << over 8 << or
	( r@+ 1? )(
		$ffffff00 and over =? ( 2drop r 4 - @ 8 >> $ff and rdrop ; ) drop
		) 2drop rdrop
	-1 ;

:JPGDecode | a list -- a nro
	>r
	read1bit
	0 ( 16 <? )( 1+ | bit len --
		r searchcode 0 >=? ( nip nip rdrop ; ) drop
		swap 2* rot  | len bit a
		read1bit rot or	 | len a bit
		rot ) 2drop
	rdrop -1 ;

|---------------
:JPGGetBlock | out --
	;

|---------------
:build34 | a -- a ;3 components (Y-Cb-Cr) 4 samplesY
	'YVector1 JPGGetBlock |(, Image.HuffDCTableY,    Image.HuffACTableY,    Image.QuantTableY,    &dcY);
	'YVector2 JPGGetBlock |(, Image.HuffDCTableY,    Image.HuffACTableY,    Image.QuantTableY,    &dcY);
	'YVector3 JPGGetBlock |(, Image.HuffDCTableY,    Image.HuffACTableY,    Image.QuantTableY,    &dcY);
	'YVector4 JPGGetBlock |(, Image.HuffDCTableY,    Image.HuffACTableY,    Image.QuantTableY,    &dcY);
	'CbVector JPGGetBlock |(, Image.HuffDCTableCbCr, Image.HuffACTableCbCr, Image.QuantTableCbCr, &dcCb);
	'CrVector JPGGetBlock |(, Image.HuffDCTableCbCr, Image.HuffACTableCbCr, Image.QuantTableCbCr, &dcCr);

	;

:buildimg
	0 'bitl !
	0 'yindex !
	Image.NumComp 4 << Image.SamplesY or
	$34 =? ( drop build34 ; )
	drop ;

:decodetype | adr v -- adr
|	trace
	$ffc0 =? ( drop JPGGetImageAttr ; )
	$ffc1 =? ( drop JPGGetImageAttr ; )
	$ffc4 =? ( drop JPGGetHuffTables ; )
	$ffdb =? ( drop PGGetQuantTables ; )
	$ffdd =? ( drop readNumber 'Restart ! ; )
	$ffda =? ( drop JPGGetSOS 0 ; )
	$fffe =? ( drop readComm ; )
	$ffe0 >=? ( $ffef <=? ( drop readComm ; ) )
|	trace
	2drop 0 0 ;

:loadjpg | "" -- adr/0
	here swap load
	here =? ( drop 0 ; ) 'emem !
	here dup 'imem !
	get16 $ffd8 <>? ( 2drop 0 ; ) drop
	( get16 decodetype 0? ) drop
	0? ( ; )
	buildimg ;

|---------------------------------

:dumptable
	>r
	256 ( 1? )( 1- r@+ "%h " allowcr print ) drop
	cr rdrop ;

:dumpquad
	'QuantTable >r
	16 ( 1? )( 1-
		8 ( 1? )( 1- r@+ "%d " print ) drop cr
		) drop rdrop ;

| 		dumpquad
|		'HuffmanDC0 dumptable 'HuffmanDC1 dumptable
|		'HuffmanAC0 dumptable 'HuffmanAC1 dumptable

#test ( $57 $5a $a5 $8d $99 $22 $7b $98 $d1 $87 $f0 $e7 $2d $f9 $e $69 $4a $4a $2a $ed $8d $26 )
|4  0 0
|4 4 0 10
|5 5 0 20
|4 4 0 -14
|4 4 0 -12
|1 1 0 1
|1 1 0 1
|1 1 0 -1
|3 3 0 7
|4 4 0 9 
|3 3 0 -4
|2 2 0 -3
|2 2 0 2
|1 1 0 -1
|66 2 4 -2
|17 1 1 1
|17 1 1 1
|2 2 0 2
|145 1 9 -1
|1 1 0 -1
|33 1 2 1
|0 0 0 0
:testhuff
	0 'bitl !
	'test 'HuffmanDC0 jpgdecode
	"%d " print cr | 1
	'HuffmanAC0 jpgdecode
	"%d " print
	cr
	'HuffmanAC0 jpgdecode
	"%d " print
	cr
	'HuffmanAC0 jpgdecode
	"%d " print
	cr
	'HuffmanAC0 jpgdecode
	"%d " print
	cr
	'HuffmanAC0 jpgdecode
	"%d " print
	cr
	drop
	trace

	;

:main
	mark
	"r4\dev\smiley.jpg" loadjpg 'test !

	show clrscr
		cr cr cr cr
|		'HuffmanAc1 dumptable
		testhuff
		'exit >esc<
		cminiflecha ;

: main ;