| JPG decoder
| PHREDA 2015
|-----------------------
^r4/lib/gui.txt
^r4/lib/trace.txt

#imem
#emem

#restart

#imgrows
#imgcols
#Image.NumComp
#Image.HuffACTableY
#Image.HuffDCTableY
#Image.HuffACTableCbCr
#Image.HuffDCTableCbCr
#Image.SamplesY
#Image.QuantTableY
#Image.SamplesCbCr
#Image.QuantTableCbCr

| index(16)-length(8)-code(8)
#HuffmanDC0 )( 1028
#HuffmanDC1 )( 1028
#HuffmanAC0 )( 1028
#HuffmanAC1 )( 1028

#QuantTable )( 512 | 2x8x8

#JPGzz (
 0  1  8 16  9  2  3 10 17 24 32 25 18 11  4  5
12 19 26 33 40 48 41 34 27 20 13  6  7 14 21 28
35 42 49 56 57 50 43 36 29 22 15 23 30 37 44 51
58 59 52 45 38 31 39 46 53 60 61 54 47 55 62 63 -1 )

#aanscales | precomputed values scaled up by 14 bits
  16384  22725  21407  19266  16384  12873   8867   4520
  22725  31521  29692  26722  22725  17855  12299   6270
  21407  29692  27969  25172  21407  16819  11585   5906
  19266  26722  25172  22654  19266  15137  10426   5315
  16384  22725  21407  19266  16384  12873   8867   4520
  12873  17855  16819  15137  12873  10114   6967   3552
   8867  12299  11585  10426   8867   6967   4799   2446
   4520   6270   5906   5315   4520   3552   2446   1247

:get8 | adr -- adr+ 8b
	c@+ $ff and ;
:get16 | adr -- adr+ 16b
	c@+ $ff and 8 << swap c@+ $ff and rot or ;
:readNumber | adr -- adr+ 16b
	2 + get16 ;
:readComm | adr -- adr+
	get16 2 - ( 1? )( 1- swap 1+ swap ) drop ;

#bbit
#bitl

|------------------------------
:readbit | adr -- adr bit
	bitl 0? ( drop c@+ 'bbit ! 8 )
	1- 'bitl !
	bbit dup 2* 'bbit !
	7 >> 1 and ;

| index(16)-code(8)-length(8)
:decodeHuf | a list -- a nro
	>r
	readbit 1 | bitfiel cnt
	( r@+ 1? )(	| bitfield cnt code
		dup $ff and
		( pick2 >? )( >r >r >r 2* swap readbit rot or r> 1+ r> r> )
		drop 	| bitfield cnt code
		16 >> $ffff and pick2 =? ( 3drop r> 4 - @ 8 >> $ff and ; )
		drop
		) 3drop rdrop
	-1 ;

:recbits | a n -- a v
	0 rot pick2 | n 0 a n
	( 1? )( 1- rot 2* rot readbit rot or swap rot )
	drop | n nro a
	rot 1 swap << | nro a cat
	pick2 2* <=? ( drop swap ; )
	1- neg rot + ;

|--------------------------
:getcase1
	swap
	get8 dup 15 and swap 4 >> * 'Image.SamplesY !
	get8 'Image.QuantTableY !
	swap ;

:getcase2
	swap
	get8 dup 15 and swap 4 >> * 'Image.SamplesCbCr !
	get8 'Image.QuantTableCbCr !
	swap ;

:JPGGetImageAttr | adr -- adr+
	3 +	| Length of segment
	get16 'imgrows !
	get16 'imgcols !
	get8	| Number of components
	( 1? )( swap
		get8
		1- 0? ( getcase1 )( getcase2 )
		drop swap 1- ) drop ;

|----------------------------------
#curnum

:getHuffTable | a table -- a total
	>r
	emem >r
	16 ( 1? )( 1- swap
		get8 r!+ swap ) drop
	rdrop
	0 'curnum !
	emem 0 ( 16 <? )( 1+	| adr ht i
		rot rot 			| i adr ht
		@+ ( 1? )( 1- rot 	| i ht cnt adr
	        get8 8 << pick4 or curnum 16 << or r!+
			1 'curnum +!
			rot rot ) drop
		curnum 2* 'curnum !
		rot ) 2drop			| adr ht
	rdrop ;

:tableHuff | a -- a
	get8
	$00 =? ( drop 'HuffmanDC0 getHuffTable ; )
	$01 =? ( drop 'HuffmanDC1 getHuffTable ; )
	$10 =? ( drop 'HuffmanAC0 getHuffTable ; )
	$11 =? ( drop 'HuffmanAC1 getHuffTable ; )
	drop ;

:JPGGetHuffTables | a -- a
	get16 2 - over + swap
	( over <? )( tableHuff ) nip ;

|-----------------
:PGGetQuantTables | a -- a
	get16 2 - over + swap
	( over <? )(
		get8
		1 and 8 << 'QuantTable + >r
		'jpgzz ( c@+ 0 >=? )(	| a zz index
			2 << rot get8		| zz index a byte
			pick2 'aanscales + @ * 12 >> | zz index a value
			rot r + !			| zz a
			swap ) 2drop
		rdrop
		) nip ;

|-----------------
:SOSline
	get8
	1 =? ( drop get8 dup 15 and 'Image.HuffACTableY ! 4 >> 'Image.HuffDCTableY ! ; )
	drop get8 dup 15 and 'Image.HuffACTableCbCr ! 4 >> 'Image.HuffDCTableCbCr ! ;

:JPGGetSOS | a --
	2 + get8 dup 'Image.NumComp !
	( 1? )(	1- swap SOSline swap ) drop
	3 + ;

|-----------------
#YVector1 )( 256 |[8][8];              // 4 vectors for Y attribute
#YVector2 )( 256 |[8][8];              // (not all may be needed)
#YVector3 )( 256 |[8][8];
#YVector4 )( 256 |[8][8];
#CbVector )( 256 |[8][8];              // 1 vector for Cb attribute
#CrVector )( 256 |[8][8];
#yindex

#dcY
#dcCb
#dcCr

#dcCoef
#huffAC
#huffDC
#QuantNum

#tempa )( 256
#tempw )( 256

:cleartempa
	'tempa >r 64 ( 1? )( 0 r!+ 1- ) drop rdrop ;

:]inarray | n n -- d
	swap 3 << + 2 << 'tempa + ;

:]warray | n n -- d
	swap 3 << + 2 << 'tempw + ;

:]qarray | n n -- d
	swap 3 << + 2 << QuantNum + ;

:dumpa
	clrscr cr cr cr
	'tempa >r
	8 ( 1? )( 1-
		8 ( 1? )( 1-
		r@+ "%d " print
		) drop
		cr
	) drop rdrop
	trace
	;

:dumpo | v
	clrscr cr cr cr
	>r
	8 ( 1? )( 1-
		8 ( 1? )( 1-
		r@+ "%d " print
		) drop
		cr
	) drop rdrop
	trace
	;

|----------------------------------------
:1.082392200*  277 * 8 >> ;
:1.414213562*  362 * 8 >> ;
:1.847759065*  473 * 8 >> ;
:2.613125930*  669 * 8 >> ;

#t0 #t1 #t2 #t3 #t4 #t5 #t6 #t7
#a0 #a1 #a2 #a3

:pass1 | col -- col
    0 over ]inarray @ 0 pick2 ]qarray @ * 't0 !
    2 over ]inarray @ 2 pick2 ]qarray @ * 't1 !
    4 over ]inarray @ 4 pick2 ]qarray @ * 't2 !
    6 over ]inarray @ 6 pick2 ]qarray @ * 't3 !
	t0 t2 + 'a0 !
	t0 t2 - 'a1 !
	t1 t3 + 'a3 !
	t1 t3 - 362 * 8 >> a2 - 'a2 !
	a0 a3 + 't0 !
	a0 a3 - 't3 !
	a1 a2 + 't1 !
	a1 a2 - 't2 !
    1 over ]inarray @ 1 pick2 ]qarray @ * 't4 !
    3 over ]inarray @ 3 pick2 ]qarray @ * 't5 !
    5 over ]inarray @ 5 pick2 ]qarray @ * 't6 !
    7 over ]inarray @ 7 pick2 ]qarray @ * 't7 !
	t6 t5 + 'a3 !
	t6 t5 - 'a0 !
	t4 t7 + 'a1 !
	t4 t7 - 'a2 !
	a1 a3 + 't7 !
	a0 a2 + 473 * 8 >>
	a0 -669 * 8 >> over + t7 - 't6 !
	a1 a3 - 362 * 8 >> t6 - 't5 !
	a2 227 * 8 >> swap - t5 + 't4 !
	t0 t7 + 0 pick2 ]warray !
	t0 t7 - 7 pick2 ]warray !
	t1 t6 + 1 pick2 ]warray !
	t1 t6 - 6 pick2 ]warray !
	t2 t5 + 2 pick2 ]warray !
	t2 t5 - 5 pick2 ]warray !
	t3 t4 + 4 pick2 ]warray !
	t3 t4 - 3 pick2 ]warray !
	;

:]out | out col val x y
	swap 3 << + 2 << pick3 + ;

:pass2 | out col -- out col
	dup 0 ]warray @ over 4 ]warray @ + 'a0 !
	dup 0 ]warray @ over 4 ]warray @ - 'a1 !
	dup 2 ]warray @ over 6 ]warray @ + 'a3 !
	dup 2 ]warray @ over 6 ]warray @ - 362 * 8 >> a3 - 'a2 !
	a0 a3 + 't0 !
	a0 a3 - 't3 !
	a1 a2 + 't1 !
	a1 a2 - 't2 !
	dup 5 ]warray @ over 3 ]warray @ + 'a3 !
	dup 5 ]warray @ over 3 ]warray @ - 'a0 !
	dup 1 ]warray @ over 7 ]warray @ + 'a1 !
	dup 1 ]warray @ over 7 ]warray @ - 'a2 !
	a1 a3 + 't7 !
	a0 a2 + 473 * 8 >>
	a0 -669 * 8 >> over + t7 - 't6 !
	a0 a3 - 362 * 8 >> t6 - 't5 !
	a2 277 * 8 >> swap - t5 + 't4 !
	t0 t7 + 5 >> 128 + 255 clamp0max over 0 ]out !
	t0 t7 - 5 >> 128 + 255 clamp0max over 7 ]out !
	t1 t6 + 5 >> 128 + 255 clamp0max over 1 ]out !
	t1 t6 - 5 >> 128 + 255 clamp0max over 6 ]out !
	t2 t5 + 5 >> 128 + 255 clamp0max over 2 ]out !
	t2 t5 - 5 >> 128 + 255 clamp0max over 5 ]out !
	t3 t4 + 5 >> 128 + 255 clamp0max over 4 ]out !
	t3 t4 - 5 >> 128 + 255 clamp0max over 3 ]out !
	;

:JPGidct | out --
	0 ( 8 <? )( pass1 1+ )
	drop
	0 ( 8 <? )( pass2 1+ )
	2drop ;

|---------------
:JPGGetBlock | a out -- a
	swap
	cleartempa
	huffDC decodehuf recbits
	dcCoef + dup 'dcCoef ! 'tempa !
	1 ( >r 	| a
		huffAC decodehuf		| a v
		dup 4 >> swap 15 and	| a zeros bit
		0? ( drop 15 <>? ( 63 + ) r+ )(
			swap r+			| a bit
			recbits			| a bitVal
			r 'jpgzz + c@ 2 << 'tempa + !
			1 r+ )
	r> 63 >? ) drop
	rdrop
	JPGidct ;

|---------------
:QuantNum! | nro --
	1 and 8 << 'QuantTable + 'QuantNum ! ;

:huffAC! | nro --
	0? ( 'HuffmanAC0 )( 'HuffmanAC1 ) nip
	'huffAC ! ;

:huffDC! | nro --
	0? ( 'HuffmanDC0 )( 'HuffmanDC1 ) nip
	'huffDC ! ;

:build34 | a -- a ;3 components (Y-Cb-Cr) 4 samplesY
	0 'dcY ! 0 'dcCb ! 0 'dcCr !
	dcY 'dcCoef !
	Image.QuantTableY QuantNum!
	Image.HuffACTableY huffAC!
	Image.HuffDCTableY huffDC!
	'YVector1 JPGGetBlock
	'YVector2 JPGGetBlock
	'YVector3 JPGGetBlock
	'YVector4 JPGGetBlock
	dcCoef 'dcY !
	dcCb 'dcCoef !
	Image.QuantTableCbCr QuantNum!
	Image.HuffACTableCbCr huffAC!
	Image.HuffDCTableCbCr huffDC!
	'CbVector JPGGetBlock
	dcCoef 'dcCb !
	dcCr 'dcCoef !
	Image.QuantTableCbCr QuantNum!
	'CrVector JPGGetBlock
	dcCoef 'dcCr !
	;

:buildimg
	0 'bitl !
	0 'yindex !
	Image.NumComp 4 << Image.SamplesY or
	$34 =? ( drop build34 ; )
	drop ;

:decodetype | adr v -- adr
|	trace
	$ffc0 =? ( drop JPGGetImageAttr ; )
	$ffc1 =? ( drop JPGGetImageAttr ; )
	$ffc4 =? ( drop JPGGetHuffTables ; )
	$ffdb =? ( drop PGGetQuantTables ; )
	$ffdd =? ( drop readNumber 'Restart ! ; )
	$ffda =? ( drop JPGGetSOS 0 ; )
	$fffe =? ( drop readComm ; )
	$ffe0 >=? ( $ffef <=? ( drop readComm ; ) )
|	trace
	2drop 0 0 ;

:loadjpg | "" -- adr/0
	here swap load
	here =? ( drop 0 ; ) 'emem !
	here dup 'imem !
	get16 $ffd8 <>? ( 2drop 0 ; ) drop
	( get16 decodetype 0? ) drop
	0? ( ; )
	buildimg ;

|---------------------------------

:dumptable
	>r
	256 ( 1? )( 1- r@+ "%h " allowcr print ) drop
	cr rdrop ;

:dumpquad
	'QuantTable >r
	16 ( 1? )( 1-
		8 ( 1? )( 1- r@+ "%d " print ) drop cr
		) drop rdrop ;


#img
:main
	mark
	"r4\dev\smiley.jpg" loadjpg 'img !
	show clrscr
		cr cr cr cr
 		dumpquad
|		'HuffmanDC0 dumptable 'HuffmanDC1 dumptable
|		'HuffmanAC0 dumptable 'HuffmanAC1 dumptable

		'exit >esc<
		cminiflecha ;

: main ;