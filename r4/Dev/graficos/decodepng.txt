| PNG decoder
| traslate from  picopng (Lode Vandevenne) and tinflate (Joergen Ibsen)
| PHREDA 2015
|------------------------------------
^r4/lib/gui.txt
^r4/lib/trace.txt

#wpng
#hpng
#dpng	| deph
#cpng	| color
#opng	| compression
#fpng	| filter
#ipng	| interlace

#key.rgb

#bbit
#bitl

#pxsize

#ipaleta
#idat
#idat>
#databyte
#img

:read32 | mem -- mem c
	@+
	dup $ff and 24 << over $ff00 and 8 << or
	over $ff0000 and 8 >> or swap 24 >> $ff and or ;

:read1bit | adr -- adr bit
	bitl 0? ( drop c@+ 'bbit ! 8 )
	1- 'bitl !
	bbit dup 2/ 'bbit !
	1 and ;

:readnbit | adr n -- adr nro
	swap 0 >r
	bbit bitl 0 | a bb bn len
	( pick4 <? )( swap	| a bb len bn
    	0? ( drop nip swap c@+ rot 8 )
		1- pick2 1 and
		pick2 << r+
		rot 2/ swap rot 1+ ) drop
	'bitl ! 'bbit !
	nip r> ;

:readbyte | adr -- adr byte
	0 'bitl ! c@+ $ff and ;

|-------
#len_bits 0 0 0 0 0 0 0  0  1  1  1  1  2  2  2  2  3  3  3  3  4  4  4   4   5   5   5   5   0   6
#len_base 3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 323
#dist_bits 0 0 0 0 1 1 2  2  3  3  4  4  5  5   6   6   7   7   8   8    9    9   10   10   11   11   12    12    13    13
#dist_base 1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769 1025 1537 2049 3073 4097 6145 8193 12289 16385 24577
#clcidx 16  17  18  0  8  7  9  6  10  5  11  4  12  3  13  2  14  1  15

#dynsta )( 1216 | (16+288)x4
#dyndta )( 1216
#codetr )( 1216
#lens )( 320
#off )( 64

#hlit
#hdist
#hclen

|-----------------------------------------
:decodesym | adr dt -- adr sym
	dup 4+ >r swap
	0 0	( 					| dt a sum cur
		2* rot read1bit		| dt sum cur a 1
		rot + rot r@+		| dt a cur sum l
		rot over -			| dt a sum l cur-l
		rot rot + swap
		-? ) rdrop
	+ 2 << rot 64 + + @ ;

:buildtree | cnt len table --
	dup >r
	16 ( 1? )( 1- 0 r!+ ) drop rdrop
	>r 2dup swap	| cnt len len cnt
	( 1? )( 1- swap
		c@+ $ff and 2 << r + 1 swap +! swap ) 2drop
	0 r !			| cnt len
	0 r 'off ( 'off 64 + <? )(
		pick2 swap !+ | 0 r 'off
		>r @+ rot + swap r>
		) 3drop
	0 ( pick2 <? )( swap c@+	| cnt n len  length
		$ff and
		1? ( 2 << 'off + dup @  | cnt n len  off valo
			1 rot +!			| cnt n len  valo
			2 << 64 + r +
			pick2 swap !
			)( drop )
		swap 1+ ) 3drop rdrop ;

:decodeloop | lenf len a sym -- a lenf len
	16 <? ( rot c!+ rot swap ; )
	16 =? ( drop over 1- c@ swap 2 readnbit 3 + | lenf len prev a n
			>r rot r> | lenf prev a len n
			( 1? )( 1- >r
				pick2 swap c!+	| lenf prev a len+
				r> ) drop
			rot drop rot swap ; )
	17 =? ( drop 3 readnbit 3 + )( drop 7 readnbit 11 + )
	rot swap | lenf a len n
	( 1? )( 1-
		0 rot c!+ swap
		) drop
	rot swap ;

:decodetree | a -- a
	5 readnbit 257 + 'hlit !
	5 readnbit 1+ 'hdist !
	4 readnbit 4+ 'hclen !
	0 0 0 0 0 'lens !+ !+ !+ !+ ! | 20 zeros in lens
	'clcidx >r
	hclen ( 1? )( 1- swap
		3 readnbit r@+	| cnt a 3b inx
		'lens + c! swap ) drop rdrop
	19 'lens 'codetr  buildtree
	'lens dup hlit hdist + + swap	| a lenf len
	( over <? )(
		rot 'codetr decodesym	| lenf len a sym
		decodeloop
		) 2drop
	hlit 'lens 'dynsta buildtree
	hdist 'lens hlit + 'dyndta buildtree ;

:fixtree
	'dynsta >r
	7 ( 1? )( 1- 0 r!+ ) drop
	24 r!+ 152 r!+ 112 r!+ 24 r+
	0
	( 24 <? )( dup 256 + r!+ 1+ )
	( 168 <? )( dup 24 - r!+ 1+ )
	( 176 <? )( dup 112 + r!+ 1+ )
	( 288 <? )( dup 32 - r!+ 1+ )
	drop rdrop
	'dyndta >r
	5 ( 1? )( 1- 0 r!+ ) drop
	32 r!+ 40 r+
	0 ( 32 <? )( dup r!+ 1+ )
	drop rdrop ;

:inflatesym | a sym -- a
	256 <? ( ,c ; )
	257 - 2 << swap 	| sym a
	over 'len_bits + @
	readnbit			| sym a length
	rot 'len_base + @ +	| a length
	swap 'dyndta decodesym | length a dist
	2 << swap			| length dist a
	over 'dist_bits + @
	readnbit			| length dist a off
	rot 'dist_base + @ + | length a offs
	here swap - rot 	| a here length
	( 1? )( 1- swap c@+ ,c swap ) 2drop ;

:nocompress | adr -- adr
	readbyte swap readbyte 8 << rot or
	swap 2 + swap
	( 1? )( 1- swap c@+ ,c swap ) drop ;

:typeinflate | adr -- adr
	2 readnbit
	0? ( drop nocompress ; )
	1- 0? ( drop fixtree )( drop decodetree )
	( 'dynsta decodesym 256 <>? )(
		inflatesym ) drop ;

:inflate | in --
	( read1bit 0? )( drop
		typeinflate ) drop
	typeinflate ;

|------ filter
#wf

:paeth2 | a b pa pb -- p
	over >=? ( 3drop ; ) 2drop nip ;

:paeth | a b c -- p
	pick2 pick2 + over - 	| a b c p
	pick3 over - abs swap	| a b c pa p
	pick3 over - abs swap	| a b c pa pb p
	pick3 - abs				| a b c pa pb pc
	pick2 >=? ( drop rot drop paeth2 ; ) | a b pa pb
	>r >r drop rot drop r> r> | b c pb pc
	paeth2 ;


:fnoneline | x y data x -- x y data
	+ ;

:fsubline | x y data x -- x y data
	pxsize - swap pxsize + swap
	( 1? )( 1- swap
		dup pxsize - c@ over c+! 1+
		swap ) drop ;

:fupline | x y data x -- x y data
	( 1? )( 1- swap
		dup wf - c@ over c+! 1+
		swap ) drop ;

:favgline | x y data x -- x y data
	pxsize ( 1? )( >r
		1- swap
		dup wf - c@ $ff and 2/ over c+! 1+ swap
		r> 1- ) drop
	( 1? )( 1- swap
		dup pxsize - c@ $ff and over wf - c@ $ff and + 2/ over c+! 1+
		swap ) drop ;

:favgline0 | x y data x -- x y data
	pxsize - swap pxsize + swap
	( 1? )( 1- swap
		dup pxsize - c@ $ff and 2/ over c+! 1+
		swap ) drop ;

:fpaeline | x y data x -- x y data
	pxsize ( 1? )( >r
		1- swap
		0 over wf - c@ $ff and 0 paeth
		over c+! 1+ swap
		r> 1- ) drop
	( 1? )( 1- swap
		dup pxsize - c@ $ff and
		over wf - c@ $ff and
		pick2 wf - pxsize - c@ $ff and
		paeth over c+! 1+
		swap ) drop ;

:fpaeline0 | x y data x -- x y data
	pxsize - swap pxsize + swap
	( 1? )( 1- swap
		dup pxsize - c@ $ff and 0 0
		paeth over c+! 1+
		swap ) drop ;

#linefilter fnoneline fsubline fupline favgline fpaeline
#linefilter0 fnoneline fsubline fnoneline favgline0 fpaeline0

|........................
:predump
	dup c@+ "%h " print
	pick3 ( 1? )( >r c@+ $ff and "%h" print  r> 1- ) 2drop
	;

:postdump
	sp
	dup pick3 -
	pick3 ( 1? )( >r c@+ $ff and "%h" print  r> 1- ) 2drop
	cr ;
|........................

:unfilter | w h data -- data
	pick2 1+ 'wf !
	swap 1- swap
| predump
	c@+ | x y data filte
	pick3 swap
	$7 and 2 << 'linefilter0 + @ exec | x y data
| postdump
	swap
	( 1? )( 1- swap
| predump
		c@+   | x y data filter
		pick3 swap
		$7 and 2 << 'linefilter + @ exec | x y data
| postdump
		swap ) drop nip ;

#adambox
$33	$33 $23 $22 $12 $11 $01 -1

:unfilteradam | --
	databyte
	'adambox >r
	( r@+ +? )(
|		clrscr cr cr cr cr cr

		wpng over 4 >> >> pxsize *
		hpng rot $f and >>
		rot unfilter

|		trace
		) 2drop rdrop ;

|------ convert
|//greyscale
:mode01 | b -- pixel ;modo 0 ; modo 0 1bits
:mode02 | b -- pixel ;modo 0 ; modo 2 1bits
:mode04 | b -- pixel ;modo 0 ; modo 4 1bits
	;
:mode08 | b -- b pixel ; modo 0 8bits
	c@+ $ff and
	key.rgb =? ( 0 )( $ff000000 )
	over 8 << dup 8 << or or or ;

|//RGB color
:mode28
	c@+ $ff and 16 << swap
	c@+ $ff and 8 <<  swap
	c@+ $ff and rot or rot or
	key.rgb <>? ( $ff000000 or ) ;

|//indexed color (palette)
:mode38
	c@+ $ff and 2 << ipaleta + @ ;

:mode34
:mode32
:mode31
	;
|//greyscale with alpha
:mode48
	c@+ $ff and
	dup 8 << dup 8 << or or
	swap c@+ 24 << rot or ;

|//RGB with alpha
:mode68
	@+ 8 >> ;

#modec

|------ interlace
| sx sy x y
#arrayadam7
8 8 0 0
8 8 4 0
4 8 0 4
4 4 2 0
2 4 0 2
2 2 1 0
1 2 0 1

:ppixel! | y x c -- y x
	pick2 wpng * pick2 + 2 << img + ! ;

:adam7step | sx sy x y --
    databyte >r
	( hpng <? )(
		r> 1+ >r
		over ( wpng <? )(
			r> modec exec swap >r
			ppixel!
			pick4 + ) drop
		 pick2 + ) 4drop
	r> 'databyte ! ;

:convertadam7
    'arrayadam7 >r
	7 ( 1? )( 1-
		r@+ r@+ r@+ r@+ | sx sy x y
		adam7step
		) drop rdrop ;

:convert
	img >r
	databyte
	hpng ( 1? )(
		swap 1+ swap
		wpng ( 1? )(
			rot modec exec r!+
			rot rot 1- ) drop
		1- ) 2drop
	rdrop
	;

|-----------------------------------------
:readlen | adr -- adr len
	dup 8 - @
	dup $ff and 24 << over $ff00 and 8 << or
	over $ff0000 and 8 >> or swap 24 >> $ff and or ;

:didat | adr -- adr'
	readlen | adr len
	idat> pick2 pick2 cmove | des scr cnt
	dup 'idat> +!
	+ ;

:dplte
	readlen | adr len
	ipaleta >r
	2dup ( +? )( 3 - swap
		c@+ swap c@+ swap c@+
		$ff and rot $ff and 8 << or rot $ff and 16 << or $ff000000 or
		r!+
		swap ) 2drop
	rdrop
	+ ;

:dtrns
	readlen | adr len
	+ ;

:readchunk | adr code -- adr'
	$54414449 =? ( drop didat ; ) | IDAT
	$45544c50 =? ( drop dplte ; ) | PLTE
	$534e5274 =? ( drop dtrns ; ) | tRNS
	drop readlen + ; | desconocido, saltea

#colchan ( 1 0 3 1 2 0 4 0 0 )
#colmode mode08 0 mode28 mode38 mode48 0 mode68

:pngheader | 'mem s-- 0/mem
	@+ $474e5089 <>? ( 2drop 0 ; ) drop
	@+ $0a1a0a0d <>? ( 2drop 0 ; ) drop
	4+ @+ $52444849 <>? ( 2drop 0 ; ) drop | IHDR
	read32 'wpng !
	read32 'hpng !
	c@+ 'dpng !
	c@+
	3 =? ( here 'ipaleta ! $3ff 'here +! ) | con paleta
	dup 'colchan + c@ dpng * 7 + 3 >> 'pxsize !
	dup 2 << 'colmode + @ 'modec !
	'cpng !
	c@+ 'opng !
	c@+ 'fpng !
	c@+	'ipng !
	here dup 'idat ! 'idat> !
	;

|-----------------------------------------
::decodePNG | 'mem -- 'memfb / 0 error
	pngheader 0? ( ; )  | header error
	$ff000000 'key.rgb !
	( 8 + @+ $444e4549 <>? )(  | IEND
		readchunk ) 2drop

	idat> dup 'databyte ! 'here !
	idat 2 + inflate
	here 'img !
	clrscr cr cr cr cr
	ipng 0? ( drop wpng pxsize * hpng databyte unfilter convert img ; ) drop
	unfilteradam
	convertadam7
	img
	;


|------
:testpal
	ipaleta 256 ( 1? )( 1- swap
		@+ ink
		400 pick2 op
		500 pick2 line
		swap ) 2drop ;

:drawimg
	0 0 setxy
	img 0? ( drop ; )
	>r
	hpng ( 1? )( 1-
		wpng ( 1? )( 1- r@+ px!+  ) drop
		sw wpng - px+! ) drop
		rdrop ;


:main
	mark
	here dup
	"r4/dev/graficos/test2.png" load
|	"r4/dev/graficos/basi0g08.png" load
|	"r4/dev/graficos/basi2c08.png" load
|	"r4/dev/graficos/basi3p08.png" load
|	"r4/dev/graficos/basi4a08.png" load
	over =? ( 2drop ; ) 'here !
	decodePNG
	0? ( drop ; ) drop
	show clrscr
		blanco
		drawimg
		hpng wpng "%dx%d " print
		fpng ipng cpng dpng " deph:%d color:%d interlace:%d filter:%d" print cr

|		idat ( idat> <? )(
|			c@+ $ff and "%h" allowcr print ) drop cr cr
|		idat> ( img <? )(
|			c@+ $ff and "%h" allowcr print ) drop cr cr

		'exit >esc<
		cminiflecha ;


: main ;
