| PNG decoder from
| picopng (Lode Vandevenne) and tinflate (Joergen Ibsen)
| PHREDA 2015
|------------------------------------
^r4/lib/gui.txt
^r4/lib/trace.txt


#wpng
#hpng
#dpng	| deph
#cpng	| color
#opng	| compression
#fpng	| filter
#ipng	| interlace

#key.rgb

#bytewidth
#bbit
#bitl

#ipaleta
#idat
#idat>
#databyte
#img


:read32 | mem -- mem c
	@+
	dup $ff and 24 << over $ff00 and 8 << or
	over $ff0000 and 8 >> or swap 24 >> $ff and or ;

:read1bit | adr -- adr bit
	bitl 0? ( drop c@+ 'bbit ! 8 )
	1- 'bitl !
	bbit dup 2/ 'bbit !
	1 and ;

:readnbit | adr n -- adr nro
	swap 0 >r
	bbit bitl 0 | a bb bn len
	( pick4 <? )( swap	| a bb len bn
    	0? ( drop nip swap c@+ rot 8 )
		1- pick2 1 and
		pick2 << r+
		rot 2/ swap rot 1+ ) drop
	'bitl ! 'bbit !
	nip r> ;

:readbyte | adr -- adr byte
	0 'bitl ! c@+ $ff and ;

|-------
#len_bits
0 0 0 0 0 0 0  0  1  1  1  1  2  2  2  2  3  3  3  3  4  4  4   4   5   5   5   5   0   6
#len_base
3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 323
#dist_bits
0 0 0 0 1 1 2  2  3  3  4  4  5  5   6   6   7   7   8   8    9    9   10   10   11   11   12    12    13    13
#dist_base
1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769 1025 1537 2049 3073 4097 6145 8193 12289 16385 24577

#clcidx
16  17  18  0  8  7  9  6  10  5  11  4  12  3  13  2  14  1  15

#fixsta
0 0 0 0 0 0 0 24 152 112 0 0 0 0 0 0
#fixstr
256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 0 1 2 3 4 5 6 7
8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103
104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135
136 137 138 139 140 141 142 143 280 281 282 283 284 285 286 287 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255

#fixdta
0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0
#fixdtr
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

#dynsta )( 64		| 16x4
#dynstr )( 1152	| 288x4

#dyndta )( 64		| 16x4
#dyndtr )( 1152	| 288x4

|-----------------------------------------
:decodesym | adr dt -- adr sym
	dup >r swap
	0 0	( 		| dt a sum cur
		r@+ rot over +		| dy a cur l sum+
		rot 2* rot -		| dy a sum+ cur*-
		rot read1bit rot + | dy sum+ a b+cur*-
		rot swap
		-? ) rdrop
	+ 2 << rot 64 + + @ ;

#hlit
#hdist
#hclen
#lens )( 320

#codetr )( 64	| 16x4
#codetr )( 1152	| 288x4

#off )( 64

:buildtree | cnt len table --
	dup >r
	16 ( 1? )( 1- 0 r!+ ) drop rdrop
	>r
	2dup swap | len cnt
	( 1? )( 1- 1 rot c@+ 2 << r + +! swap ) 2drop
	0 r !	| len cnt
	0 r 'off ( 'off 64 + <? )(
		pick2 swap !+ | 0 r 'off
		>r @+ rot + swap r>
		) 3drop
	0 ( over <? )( rot c@+
		1? ( 2 << 'off + dup @
			1 rot +!
			64 + r +
			pick3 swap !
			)( drop )
		rot rot ) 3drop rdrop ;

:decodeloop | lenf len a sym -- a lenf len
	16 <? ( rot c!+ rot swap ; )
	16 =? ( drop over 1- c@ swap 2 readnbit 3 + | lenf len prev a n
			>r rot r> | lenf prev a len n
			( 1? )( 1- >r
				pick2 swap c!+	| lenf prev a len+
				r> ) drop
			rot drop swap ; )
	17 =? ( drop 3 readnbit 3 + )( drop 7 readnbit 11 + )
	rot swap | lenf a len n
	( 1? )( 1-
		0 rot c!+ swap
		) drop
	;

:dump
	cr cr cr cr cr
	hlit "%d " print
	hdist "%d " print
	hclen "%d " print cr

	'lens 19 ( 1? )( 1-
		swap c@+ "%d " print swap ) 2drop
 	trace ;

:decodetree | a -- a
	5 readnbit 257 + 'hlit !
	5 readnbit 1+ 'hdist !
	4 readnbit 4+ 'hclen !
	0 0 0 0 0 'lens !+ !+ !+ !+ ! | 20 zeros in lens
	'clcidx >r
	hclen ( 1? )( 1- swap
		3 readnbit r@+	| cnt a 3b inx
		'lens + c! swap ) drop rdrop

	'codetr 'lens 19 buildtree

	'lens dup hlit hdist + swap	| a lenf len
	( over <? )(
		rot 'codetr decodesym	| lenf len a sym
		decodeloop
		) 2drop
	'dynsta 'lens hlit buildtree
	'dyndta 'lens hlit + hdist buildtree
	;

:inflatesym | dt dl a sym -- dt dl a
	256 <? ( ,c ; )
	257 - 2 << swap 	| dt dl sym a
	over len_bits + @
	readnbit			| dt dl sym a length
	rot len_base + @ +	| dt dl a length
	swap pick3 decodesym | dt dl length a dist
	2 << swap			| dt dl length dist a
	over dist_bits + @
	readnbit			| dt dl length dist a off
	rot dist_base + @ + | dt dl length a offs
	here - rot 			| dt dl a here length
	( 1? )( 1- swap c@+ ,c swap ) 2drop ;

:inflate | a dt st -- a
	rot
	( over decodesym 256 <>? )(
		inflatesym ) drop nip nip ;

:fixhuff | adr -- adr
	'fixdta 'fixsta inflate ;

:dynhuff | adr -- adr
	decodetree
	'dyndta 'dynsta inflate ;

:nocompress | adr -- adr
	readbyte swap readbyte 8 << rot or
	swap 2 + swap
	( 1? )( 1- swap c@+ ,c swap ) drop
	;

:typeinflate | adr BTYPE -- adr
	0? ( drop nocompress ; )
	1- 0? ( drop fixhuff ; )
	drop dynhuff ;

:inflate | in --
	dup ( drop read1bit swap | bfinal adr
		2 readnbit			| bfinal adr BTYPE
		typeinflate
		swap 0? ) 2drop ;

|-----------------------------------------
:pngheader | 'mem s-- 0/mem
	@+ $474e5089 <>? ( 2drop 0 ; ) drop
	@+ $0a1a0a0d <>? ( 2drop 0 ; ) drop
	4+ @+ $52444849 <>? ( 2drop 0 ; ) drop | IHDR
	read32 'wpng !
	read32 'hpng !
	c@+ 'dpng !
	c@+ 3 =? ( here 'ipaleta ! $3ff 'here +! ) | con paleta
	'cpng !
	c@+ 1? ( 2drop 0 ; )	| error: only compression method 0 is allowed in the specification
	'opng !
	c@+ 1? ( 2drop 0 ; )	| error: only filter method 0 is allowed in the specification
	'fpng !
	c@+	1 >? ( 2drop 0 ; )	| error: only interlace methods 0 and 1 exist in the specification
	'ipng !
	here dup 'idat ! 'idat> !
	;

|-----------------------------------------
:readlen | adr -- adr len
	dup 8 - @
	dup $ff and 24 << over $ff00 and 8 << or
	over $ff0000 and 8 >> or swap 24 >> $ff and or ;

:didat | adr -- adr'
	readlen | adr len
	idat> pick2 pick2 cmove | des scr cnt
	dup 'idat> +!
	+ ;

:dplte
	readlen | adr len
	ipaleta >r
	2dup ( +? )( 3 - swap
		c@+ swap c@+ swap c@+
		$ff and rot $ff and 8 << or rot $ff and 16 << or $ff000000 or
		r!+
		swap ) 2drop
	rdrop
	+ ;

:dtrns
	readlen | adr len
	+ ;

:readchunk | adr code -- adr'
	$54414449 =? ( drop didat ; ) | IDAT
	$45544c50 =? ( drop dplte ; ) | PLTE
	$534e5274 =? ( drop dtrns ; ) | tRNS
	drop readlen + ; | desconocido, saltea


|------ convert
|//greyscale
:mode01 | b -- b pixel ;modo 0 ; modo 0 1bits
:mode02 | b -- b pixel ;modo 0 ; modo 2 1bits
:mode04 | b -- b pixel ;modo 0 ; modo 4 1bits
	;
:mode08 | b -- b pixel ; modo 0 8bits
	c@+ $ff and
	key.rgb =? ( 0 )( $ff000000 )
	over 8 << dup 8 << or or or ;

|//RGB color
:mode28
	c@+ $ff and  16 << swap c@+ $ff and 8 <<  swap c@+ $ff and rot or rot or
	key.rgb <>? ( $ff000000 or ) ;

|//indexed color (palette)
:mode38
	c@+ $ff and 2 << ipaleta + @ ;

:mode34
:mode32
:mode31
	;
|//greyscale with alpha
:mode48
	c@+ $ff and
	dup 8 << dup 8 << or or
	swap c@+ 24 << rot or ;
|//RGB with alpha
:mode68
	@+ ;

|------ filter
:fnone
	;
:fsub
	;
:fup
	;
:favg
	;

:paeth2 | a b pa pb -- p
	over >=? ( 3drop ; ) 2drop nip ;

:paeth | a b c -- p
	pick2 pick2 + over - 	| a b c p
	pick3 over - abs swap	| a b c pa p
	pick3 over - abs swap	| a b c pa pb p
	pick3 - abs				| a b c pa pb pc
	pick2 >=? ( drop rot drop paeth2 ; ) | a b pa pb
	>r >r drop rot drop r> r> | b c pb pc
	paeth2 ;

:fpaeth
	;

#atfilter fnone fsub fup favg fpaeth
#xfilter 

:xfilter! | filter --
	$7 and 2 << 'atfilter + @ 'xfilter ! ;

|------ interlace
:ppixel! | y x c -- y x
	pick2 wpng * pick2 + 2 << img + ! ;

:progre
	;

| sx sy x y
#arrayadam7
8 8 0 0
8 8 4 0
4 8 0 4
4 4 2 0
2 4 0 2
2 2 1 0
1 2 0 1

:adam7step | sx sy x y --
	( hpng <? )(
		databyte c@+ dup "%d " print cr
		xfilter! 'databyte !

		over ( wpng <? )(
			databyte mode08 ppixel! 'databyte !

			pick4 + ) drop
		 pick2 + ) 4drop ;

:adam7
    'arrayadam7 >r
	7 ( 1? )( 1-
		r@+ r@+ r@+ r@+ | sx sy x y
		adam7step
		) drop rdrop ;

|-----------------------------------------
::decodePNG | 'mem -- 'memfb / 0 error
	pngheader 0? ( ; )  | header error
	$ff000000 'key.rgb !
	( 8 + @+ $444e4549 <>? )(  | IEND
		readchunk ) 2drop
	idat> dup 'databyte ! 'here !
	idat 2 + inflate
	here 'img !

|	bbp 7 + 3 >> 'bytewidth !
|	hpng wpng * bpp * 7 + 3 >> 'outlength !

	ipng 0? ( drop progre img ; ) drop
	adam7 img ;

|------
:testpal
	ipaleta 256 ( 1? )( 1- swap
		@+ ink
		400 pick2 op
		500 pick2 line
		swap ) 2drop ;

:drawimg
	10 10 setxy
	img
	>r
	hpng ( 1? )( 1-
		wpng ( 1? )( 1- r@+ px!+  ) drop
		sw wpng - px+! ) drop
		rdrop ;


:main
	mark
	here dup
|	"r4/dev/graficos/test2.png" load
	"r4/dev/graficos/basi0g08.png" load
	over =? ( 2drop ; ) drop
	clrscr blanco
	decodePNG
	0? ( drop ; ) drop
|	waitkey waitkey
	show clrscr
		blanco
|		drawimg
		hpng wpng "%dx%d " print
		fpng ipng cpng dpng " deph:%d color:%d interlace:%d filter:%d" print cr

		idat ( idat> <? )(
			c@+ $ff and "%h" allowcr print ) drop cr cr
		idat> ( img <? )(
			c@+ $ff and "%h" allowcr print ) drop cr cr



		'exit >esc<
		cminiflecha ;


: main ;
